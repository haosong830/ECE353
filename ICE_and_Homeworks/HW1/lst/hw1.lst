


ARM Macro Assembler    Page 1 


    1 00000000         ; hw1.s ECE353
    2 00000000         
    3 00000000         
    4 00000000                 export           hw1_search_memory
    5 00000000                 import           WS2812B_write
    6 00000000         
    7 00000000 00000004 
                       WORD    EQU              4
    8 00000000 00000002 
                       HALF_WORD
                               EQU              2
    9 00000000 00000001 
                       BYTE    EQU              1
   10 00000000         
   11 00000000         ;**********************************************
   12 00000000         ; SRAM
   13 00000000         ;**********************************************
   14 00000000                 AREA             SRAM, READWRITE
   15 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 LED_ARRAY
                               SPACE            6*WORD
   16 00000018                 align
   17 00000018         
   18 00000018         ;**********************************************
   19 00000018         ; Constant Variables (FLASH) Segment
   20 00000018         ;**********************************************
   21 00000018                 AREA             FLASH, CODE, READONLY
   22 00000000                 align
   23 00000000         ; All functions are callee saved.
   24 00000000         
   25 00000000         
   26 00000000         ; Description
   27 00000000         ; Updates the WS2812B LEDs with the current values in th
                       e LED_ARRAY
   28 00000000         ; Uses the supplied function WS2812B_write to update the
                        colors
   29 00000000         
   30 00000000         ; Parameters
   31 00000000         ; NONE
   32 00000000         
   33 00000000         ; Returns
   34 00000000         ; NOTHING
   35 00000000         ;
   36 00000000         hw1_update_leds
                               PROC
   37 00000000         ; Need to save LR for nested function call
   38 00000000 B506            PUSH             {R1, R2, LR}
   39 00000002         ; Load Array address and # LEDS for function call to WS2
                       812B_write
   40 00000002 498F            LDR              R1, =(LED_ARRAY)
   41 00000004 F04F 0208       MOV              R2, #8
   42 00000008 F7FF FFFE       BL               WS2812B_write
   43 0000000C BD06            POP              {R1, R2, PC}



ARM Macro Assembler    Page 2 


   44 0000000E 4770            BX               LR
   45 00000010                 ENDP
   46 00000010         
   47 00000010         
   48 00000010         
   49 00000010         ; Description
   50 00000010         ; Converts a single ASCII HEX character to its numerical
                        value. 
   51 00000010         ; Valid characters are 0-9, a-f , A-F
   52 00000010         
   53 00000010         ; Parameters
   54 00000010         ; R0 - ASCII Char
   55 00000010         
   56 00000010         ; Returns
   57 00000010         ; R0 - numerical value. If invalid, return 0xFFFFFFFF
   58 00000010         ;
   59 00000010         hw1_ascii_to_hex
                               PROC
   60 00000010         ; Need to save LR for nested function call
   61 00000010 B502            PUSH             {R1, LR}
   62 00000012         
   63 00000012         ; 'a'-'f' = 0x61 - 0x66
   64 00000012         ; 'A'-'F' = 0x41 - 0x46
   65 00000012         ; '0'-'9' = 0x30 - 0x39
   66 00000012         characters_a_f
   67 00000012         ; First check if greater than 'f'
   68 00000012 2866            CMP              R0, #0x66
   69 00000014         ; If it is, invalid, so set R0 to -1 and return
   70 00000014 BFC8 F04F 
              30FF             MOVGT            R0, #0xFFFFFFFF
   71 0000001A DC10            BGT              return
   72 0000001C         ; Then check if less than 'a'
   73 0000001C 2861            CMP              R0, #0x61
   74 0000001E         ; if it is, then check if 'A' through 'F'
   75 0000001E DB02            BLT              characters_A_F
   76 00000020         ; otherwise, character is 'a' - 'f'. 
   77 00000020         ; Subtract #87 to convert to hex value and return! :) 
   78 00000020 F1A0 0057       SUB              R0, R0, #87
   79 00000024 E00B            B                return
   80 00000026         
   81 00000026         characters_A_F
   82 00000026         ; Now check if greater than 'F'
   83 00000026 2846            CMP              R0, #0x46
   84 00000028         ; If it is, invalid, so set R0 to -1 and return
   85 00000028 BFC8 F04F 
              30FF             MOVGT            R0, #0xFFFFFFFF
   86 0000002E DC06            BGT              return
   87 00000030         ; Then check if less than 'A'
   88 00000030 2841            CMP              R0, #0x41
   89 00000032         ; if it is, finally check if '0' - '9'
   90 00000032 DB02            BLT              characters_0_9
   91 00000034         ; otherwise, character is 'A' - 'F'. 
   92 00000034         ; subtract #55 to convert to hex value and return!  :)
   93 00000034 F1A0 0037       SUB              R0, R0, #55
   94 00000038 E001            B                return
   95 0000003A         
   96 0000003A         characters_0_9
   97 0000003A         ; if not 'a'-'f' or 'A'-'F' call function to see if '0'-
                       '9'



ARM Macro Assembler    Page 3 


   98 0000003A         ; if not '0'-'9' either, R0 will be 0xFFFFFFFF
   99 0000003A F7FF FFFE       BL               hw1_ascii_to_dec
  100 0000003E         return
  101 0000003E BD02            POP              {R1, PC}
  102 00000040 4770            BX               LR
  103 00000042                 ENDP
  104 00000042         
  105 00000042         
  106 00000042         ; Description
  107 00000042         ; Converts a single ASCII DECIMAL character to its numer
                       ical value. 
  108 00000042         ; Valid characters are 0-9. 
  109 00000042         ;  Will be called from within hw1_ascii_to_hex
  110 00000042         
  111 00000042         ; Parameters
  112 00000042         ; R0 - ASCII Char
  113 00000042         
  114 00000042         ; Returns
  115 00000042         ;  R0 -  numerical value. If invalid, return 0xFFFFFFFF
  116 00000042         ;
  117 00000042         hw1_ascii_to_dec
                               PROC
  118 00000042         ; '0'-'9' = 48 - 57 (decimal)
  119 00000042         ; Check if less than '0'. And update flags
  120 00000042 3830            SUBS             R0, #48
  121 00000044         ; if it is, invalid
  122 00000044 BFB8 F04F 
              30FF             MOVLT            R0, #0xFFFFFFFF
  123 0000004A 4770            BX               LR
  124 0000004C                 ENDP
  125 0000004C         
  126 0000004C         
  127 0000004C         ; Description
  128 0000004C         ; Turns off all of the WS2812B LEDs by writing 0x0000000
                       0 to each LED
  129 0000004C         ; Should be called with 'LOAD'
  130 0000004C         
  131 0000004C         ; Parameters
  132 0000004C         ; NONE
  133 0000004C         
  134 0000004C         ; Returns
  135 0000004C         ; NOTHING
  136 0000004C         ;
  137 0000004C         hw1_init
                               PROC
  138 0000004C B507            PUSH             {R0-R2, LR}
  139 0000004E         ; set R0 to 0
  140 0000004E F04F 0000       MOV              R0, #0x00000000
  141 00000052         ; load array address 
  142 00000052 497B            LDR              R1, =(LED_ARRAY)
  143 00000054         
  144 00000054         
  145 00000054         ; LED_ARRAY is 24 bytes, or 6 words. 
  146 00000054         ; Set all of those bytes to zero.
  147 00000054 F841 0B04       STR              R0, [R1], #4
  148 00000058 F841 0B04       STR              R0, [R1], #4
  149 0000005C F841 0B04       STR              R0, [R1], #4
  150 00000060 F841 0B04       STR              R0, [R1], #4
  151 00000064 F841 0B04       STR              R0, [R1], #4



ARM Macro Assembler    Page 4 


  152 00000068 6008            STR              R0, [R1]
  153 0000006A         
  154 0000006A         ; call write function to
  155 0000006A         ; actually change colors of LEDs
  156 0000006A 4975            LDR              R1, =(LED_ARRAY)
  157 0000006C F04F 0208       MOV              R2, #8
  158 00000070 F7FF FFFE       BL               WS2812B_write
  159 00000074         
  160 00000074 BD07            POP              {R0-R2, PC}
  161 00000076 4770            BX               LR
  162 00000078                 ENDP
  163 00000078         
  164 00000078         ; Description
  165 00000078         ;   Updates the color of the specified LED. All other LE
                       Ds should maintain
  166 00000078         ;  their current color. Makes use of the hw1_update_leds
                        to update
  167 00000078         ;   the color of the LEDs.
  168 00000078         
  169 00000078         ; Parameters
  170 00000078         ;   R0 - LED # to be updated. Assume 0 is the leftmost L
                       ED
  171 00000078         ;   R1 - An unsigned 32 bit #. Bits 31-24 are unused. Bi
                       ts 23-0 
  172 00000078         ;  represent the color value to write to the LED
  173 00000078         
  174 00000078         ; Returns
  175 00000078         ;   NOTHING
  176 00000078         ;
  177 00000078         hw1_ledx
                               PROC
  178 00000078 B5FC            PUSH             {R2-R7, LR}
  179 0000007A         
  180 0000007A         ; Each LED takes up 3 bytes to store the color
  181 0000007A         ; R3 = green
  182 0000007A         ; R4 = red
  183 0000007A         ; R5 = blue
  184 0000007A         
  185 0000007A         ; Isolate the color value bits using shifts
  186 0000007A         
  187 0000007A         ; The blue value is stored in R1[7:0]
  188 0000007A EA4F 6501       MOV              R5, R1, LSL #24
  189 0000007E EA4F 6515       MOV              R5, R5, LSR #24
  190 00000082         ; The red value is stored in R1[15:8]
  191 00000082 EA4F 4401       MOV              R4, R1, LSL #16
  192 00000086 EA4F 6414       MOV              R4, R4, LSR #24
  193 0000008A         ; The green value is stored in R1[23:16]
  194 0000008A EA4F 2301       MOV              R3, R1, LSL #8
  195 0000008E EA4F 6313       MOV              R3, R3, LSR #24
  196 00000092         
  197 00000092         ; load the address of the led array into R2
  198 00000092 4A6B            LDR              R2, =(LED_ARRAY)
  199 00000094         
  200 00000094         ; calculate the correct led # address
  201 00000094 F04F 0707       MOV              R7, #7
  202 00000098         ; R6 <-- (7 - LED#)
  203 00000098 EBA7 0600       SUB              R6, R7, R0
  204 0000009C         ; R6 <-- (7-LED#) * 3
  205 0000009C F04F 0703       MOV              R7, #3



ARM Macro Assembler    Page 5 


  206 000000A0 FB06 F607       MUL              R6, R6, R7
  207 000000A4         ; LED_ARRAY + correct offset 
  208 000000A4 4432            ADD              R2, R2, R6
  209 000000A6         
  210 000000A6         ; store green byte in LED_ARRAY + offset + 0
  211 000000A6 7013            STRB             R3, [R2, #0]
  212 000000A8         ; store red byte in LED_ARRAY + offset + 1
  213 000000A8 7054            STRB             R4, [R2, #1]
  214 000000AA         ; store blue byte in LED_ARRAY + offset + 2
  215 000000AA 7095            STRB             R5, [R2, #2]
  216 000000AC         
  217 000000AC         ; With LED_ARRAY updated, call the update
  218 000000AC         ; leds function to do the updating
  219 000000AC F7FF FFFE       BL               hw1_update_leds
  220 000000B0         
  221 000000B0 BDFC            POP{R2-R7,       PC}
  222 000000B2 4770            BX               LR
  223 000000B4                 ENDP
  224 000000B4         
  225 000000B4         
  226 000000B4         ; Description
  227 000000B4         ; Delays the examination of the next memory address by a
                        variable 
  228 000000B4         ; amount of time (hang)
  229 000000B4         ; Parameters
  230 000000B4         ; R0 - A 32 bit unsigned number representing the # of it
                       erations
  231 000000B4         ; of an empty for loop that must be executed.
  232 000000B4         
  233 000000B4         ; Returns
  234 000000B4         ; NOTHING
  235 000000B4         ;
  236 000000B4         hw1_wait
                               PROC
  237 000000B4 B401            PUSH             {R0}
  238 000000B6         ; Use the # iterations as a counter
  239 000000B6         ; To make the first iteration count, must add 1.
  240 000000B6         ; because first thing loop does is subtract one
  241 000000B6 F100 0001       ADD              R0, R0, #1
  242 000000BA         hang_loop_start
  243 000000BA 3801            SUBS             R0, #1
  244 000000BC         ; If (#iterations - 1) <= 0, then end loop
  245 000000BC D900            BLS              hang_loop_end
  246 000000BE         ; Otherwise, keep looping
  247 000000BE E7FC            B                hang_loop_start
  248 000000C0         hang_loop_end
  249 000000C0 BC01            POP              {R0}
  250 000000C2 4770            BX               LR
  251 000000C4                 ENDP
  252 000000C4         
  253 000000C4         
  254 000000C4         ; Description
  255 000000C4         ; This function will search through memory a byte at a t
                       ime looking for valid DISPLAY
  256 000000C4         ; commands. When a valid DISPLAY command is found, carry
                        out the corresponding
  257 000000C4         ; behavior described in the DISPLAY command table above.
                        Memory that holds invalid
  258 000000C4         ; commands are ignored. This function will examine memor



ARM Macro Assembler    Page 6 


                       y until and HALT command
  259 000000C4         ; is found.
  260 000000C4         
  261 000000C4         ; Parameters
  262 000000C4         ; R0 - The starting address of the memory that contains 
                       the commands
  263 000000C4         ;      to update LEDs.
  264 000000C4         
  265 000000C4         ; Returns
  266 000000C4         ; NOTHING
  267 000000C4         ;
  268 000000C4         hw1_search_memory
                               PROC
  269 000000C4         
  270 000000C4         ; Command    Bytes  Description
  271 000000C4         ;LOAD    4   Turn all LEDs off.
  272 000000C4         
  273 000000C4         ;HALT    4   Leave LEDs in current state, enter infinite
                        loop
  274 000000C4         
  275 000000C4         ;HANG    8   HANGXXXX = empty loop that executes X,XXX *
                        10,000 
  276 000000C4         ;        times and then exits. XXXX is a 4 digit ASCII s
                       tring
  277 000000C4         
  278 000000C4         ;LEDx    10   x represents which LED is being modified
  279 000000C4         ;        6 remaining characters indicate color intensity
                       . 
  280 000000C4         ;        5 & 6 = Green
  281 000000C4         ;        7 & 8 = Red
  282 000000C4         ;        9 & 10 = Blue
  283 000000C4         ;        Example for 2nd LED : LED2FF8800
  284 000000C4         
  285 000000C4 B51F            PUSH{R0-R4,      LR}
  286 000000C6         
  287 000000C6         ; R0 is used in ascii_to_hex and ascii_to_dec 
  288 000000C6         ; so must save in another register
  289 000000C6 4602            MOV              R2, R0
  290 000000C8         
  291 000000C8         ; Check if command is 'LOAD' which would get loaded into
                       
  292 000000C8         ; R4 as 'DAOL' since ARM is little endian. Compare the l
                       oaded word to
  293 000000C8         ; the hex represenation of 0xDAOL
  294 000000C8         start_search
  295 000000C8         
  296 000000C8         ; check if command is LOAD
  297 000000C8 F644 734C 
              F2C4 4341        MOV32            R3, #0x44414F4C
  298 000000D0 6814            LDR              R4, [R2]
  299 000000D2 429C            CMP              R4, R3
  300 000000D4 D104            BNE              command_LEDx
  301 000000D6         
  302 000000D6         ; if all command was 'LOAD'
  303 000000D6         ; then set all bytes
  304 000000D6         ; in LED_ARRAY to 0
  305 000000D6 F7FF FFFE       BL               hw1_init
  306 000000DA         ; increment the DISPLAY_CMD address in R2
  307 000000DA         ; and check next command



ARM Macro Assembler    Page 7 


  308 000000DA F102 0201       ADD              R2, R2, #1
  309 000000DE E7F3            B                start_search
  310 000000E0         
  311 000000E0         ; Check if command is 'LEDx' which would get loaded into
                       
  312 000000E0         ; R4 as 'xDEL' since ARM is little endian. Compare the l
                       oaded
  313 000000E0         ; word from R2 to hex representation of '0DEL'
  314 000000E0         command_LEDx
  315 000000E0         
  316 000000E0 6814            LDR              R4, [R2]
  317 000000E2         ; clear out the x in LEDx so can see if command is LED
  318 000000E2 F024 457F       BIC              R5, R4, #0xFF000000
  319 000000E6         ; hex represenation of 0DEL
  320 000000E6 F244 534C 
              F2C0 0344        MOV32            R3, #0x0044454C
  321 000000EE 429D            CMP              R5, R3
  322 000000F0         ; if not the right command, check if HANG command
  323 000000F0 D158            BNE              command_HANG
  324 000000F2         
  325 000000F2         
  326 000000F2         ; Once we know it's LEDx, then get value of 'x'
  327 000000F2         ; by shifting the value of the x byte to the LSB of R0
  328 000000F2 EA4F 6014       LSR              R0, R4, #24
  329 000000F6         
  330 000000F6         ; numerical value is returned in R0
  331 000000F6 F7FF FFFE       BL               hw1_ascii_to_hex
  332 000000FA         ; first check if valid
  333 000000FA F1B0 3FFF       CMP              R0, #0xFFFFFFFF
  334 000000FE         ; if invalid, then increment command address and 
  335 000000FE         ; start search again
  336 000000FE BF08 1C52       ADDEQ            R2, R2, #1
  337 00000102 D0E1            BEQ              start_search
  338 00000104         ; if valid, check if 0-7
  339 00000104 2807            CMP              R0, #7
  340 00000106         ; if invalid, then increment command address and 
  341 00000106         ; start search again
  342 00000106 BFC8 1C52       ADDGT            R2, R2, #1
  343 0000010A DCDD            BGT              start_search
  344 0000010C         
  345 0000010C         ; save value of R0 in R4 so we can use it for call
  346 0000010C         ; to ledx later
  347 0000010C 4604            MOV              R4, R0
  348 0000010E         
  349 0000010E         ; now that we know its LEDx, check the next 6 bytes afte
                       r 'x' to 
  350 0000010E         ; get the color values and load them into R1
  351 0000010E         ; hw1_ledx takes R0 as the #LED and R1 as the color valu
                       es
  352 0000010E         
  353 0000010E         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GREEN;;;;;;;;;;;;;;;;;;;;;
                       ;;;;;
  354 0000010E 7910            LDRB             R0, [R2, #4] ; R0 <-- character
                                                             5 (green)
  355 00000110 F7FF FFFE       BL               hw1_ascii_to_hex
  356 00000114         ; first check if valid result
  357 00000114 F1B0 3FFF       CMP              R0, #0xFFFFFFFF
  358 00000118         ; if invalid, then increment command address and 
  359 00000118         ; start search again



ARM Macro Assembler    Page 8 


  360 00000118 BF08 1C52       ADDEQ            R2, R2, #1
  361 0000011C D0D4            BEQ              start_search
  362 0000011E         ; valid result, so now put the resulting green color 
  363 0000011E 4601            MOV              R1, R0
  364 00000120         
  365 00000120 7950            LDRB             R0, [R2, #5] ; R0 <-- character
                                                             6 (green)
  366 00000122 F7FF FFFE       BL               hw1_ascii_to_hex
  367 00000126         ; first check if valid result
  368 00000126 F1B0 3FFF       CMP              R0, #0xFFFFFFFF
  369 0000012A         ; if invalid, then increment command address and 
  370 0000012A         ; start search again
  371 0000012A BF08 1C52       ADDEQ            R2, R2, #1
  372 0000012E D0CB            BEQ              start_search
  373 00000130         ; valid result, so now put the resulting green color 
  374 00000130 EA4F 1101       LSL              R1, R1, #4
  375 00000134 EA41 0100       ORR              R1, R1, R0
  376 00000138         
  377 00000138         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;RED;;;;;;;;;;;;;;;;;;;;;;;
                       ;;;
  378 00000138 7990            LDRB             R0, [R2, #6] ; R0 <-- character
                                                             7 (red)
  379 0000013A F7FF FFFE       BL               hw1_ascii_to_hex
  380 0000013E         ; first check if valid result
  381 0000013E F1B0 3FFF       CMP              R0, #0xFFFFFFFF
  382 00000142         ; if invalid, then increment command address and 
  383 00000142         ; start search again
  384 00000142 BF08 1C52       ADDEQ            R2, R2, #1
  385 00000146 D0BF            BEQ              start_search
  386 00000148         ; valid result, so now put the resulting red color 
  387 00000148 EA4F 1101       LSL              R1, R1, #4
  388 0000014C EA41 0100       ORR              R1, R1, R0
  389 00000150         
  390 00000150 79D0            LDRB             R0, [R2, #7] ; R0 <-- character
                                                             8 (red)
  391 00000152 F7FF FFFE       BL               hw1_ascii_to_hex
  392 00000156         ; first check if valid result
  393 00000156 F1B0 3FFF       CMP              R0, #0xFFFFFFFF
  394 0000015A         ; if invalid, then increment command address and 
  395 0000015A         ; start search again
  396 0000015A BF08 1C52       ADDEQ            R2, R2, #1
  397 0000015E D0B3            BEQ              start_search
  398 00000160         ; valid result, so now put the resulting red color 
  399 00000160 EA4F 1101       LSL              R1, R1, #4
  400 00000164 EA41 0100       ORR              R1, R1, R0
  401 00000168         
  402 00000168         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;BLUE;;;;;;;;;;;;;;;;;;;;;;
                       ;;;;
  403 00000168 7A10            LDRB             R0, [R2, #8] ; R0 <-- character
                                                             9 (blue)
  404 0000016A F7FF FFFE       BL               hw1_ascii_to_hex
  405 0000016E         ; first check if valid result
  406 0000016E F1B0 3FFF       CMP              R0, #0xFFFFFFFF
  407 00000172         ; if invalid, then increment command address and 
  408 00000172         ; start search again
  409 00000172 BF08 1C52       ADDEQ            R2, R2, #1
  410 00000176 D0A7            BEQ              start_search
  411 00000178         ; valid result, so now put the resulting blue color 
  412 00000178 EA4F 1101       LSL              R1, R1, #4



ARM Macro Assembler    Page 9 


  413 0000017C EA41 0100       ORR              R1, R1, R0
  414 00000180         
  415 00000180 7A50            LDRB             R0, [R2, #9] ; R0 <-- character
                                                             10 (blue)
  416 00000182 F7FF FFFE       BL               hw1_ascii_to_hex
  417 00000186         ; first check if valid result
  418 00000186 F1B0 3FFF       CMP              R0, #0xFFFFFFFF
  419 0000018A         ; if invalid, then increment command address and 
  420 0000018A         ; start search again
  421 0000018A BF08 1C52       ADDEQ            R2, R2, #1
  422 0000018E D09B            BEQ              start_search
  423 00000190         ; valid result, so now put the resulting red color 
  424 00000190 EA4F 1101       LSL              R1, R1, #4
  425 00000194 EA41 0100       ORR              R1, R1, R0
  426 00000198         
  427 00000198         ; now the green value is in R1[23:16]
  428 00000198         ; the red in R1[15:8]
  429 00000198         ; and blue in R1[7:0]
  430 00000198         
  431 00000198         ; call ledx function to set the colors
  432 00000198         ; R1 holds the colors
  433 00000198         ; R0 holds the LED. Get LED# from R4 where we saved prev
                       iously
  434 00000198 4620            MOV              R0, R4
  435 0000019A F7FF FFFE       BL               hw1_ledx
  436 0000019E         
  437 0000019E         ; increment to next command
  438 0000019E F102 0201       ADD              R2, R2, #1
  439 000001A2         ; now, start search over and check all possibilties
  440 000001A2         ; of the next command
  441 000001A2 E791            B                start_search
  442 000001A4         
  443 000001A4         ; To check if 'HANG', see if loaded word in R4 is equiva
                       lent
  444 000001A4         ; to 'GNAH', since ARM is little endian. Do this by chec
                       king if the hex
  445 000001A4         ; represenation of 'GNAH' is equal to loaded word
  446 000001A4         command_HANG
  447 000001A4 6814            LDR              R4, [R2]
  448 000001A6 F244 1348 
              F2C4 734E        MOV32            R3, #0x474E4148
  449 000001AE 429C            CMP              R4, R3
  450 000001B0         ; if loaded word and hex representation of 'TLAH' not eq
                       ual
  451 000001B0         ; then check if command is 'HALT'
  452 000001B0 D138            BNE              command_HALT
  453 000001B2         
  454 000001B2         ; now that we know command is HANG, must check next
  455 000001B2         ; 4 bytes of characters to see how long to halt for
  456 000001B2         
  457 000001B2         ; example 4 digit ASCII value = 5604
  458 000001B2         ;;;;;;;;;;;;;;;;;;;;;;;;1000th place;;;;;;;;;;;;;;;;;;;;
                       ;;;;
  459 000001B2 7910            LDRB             R0, [R2, #4]
  460 000001B4 F7FF FFFE       BL               hw1_ascii_to_hex
  461 000001B8         ; first check if valid result
  462 000001B8 F1B0 3FFF       CMP              R0, #0xFFFFFFFF
  463 000001BC         ; if invalid, then increment command address and 
  464 000001BC         ; start search again



ARM Macro Assembler    Page 10 


  465 000001BC BF08 1C52       ADDEQ            R2, R2, #1
  466 000001C0 D082            BEQ              start_search
  467 000001C2         ; if valid, this number is in the 1000th place so
  468 000001C2         ; multiply it by 1000 and place in R3
  469 000001C2 F44F 747A       MOV              R4, #1000
  470 000001C6         ; R3 <-- 5 * 1000
  471 000001C6 FB00 F304       MUL              R3, R0, R4
  472 000001CA         
  473 000001CA         ;;;;;;;;;;;;;;;;;;;;;;;;100th place;;;;;;;;;;;;;;;;;;;;;
                       ;;;
  474 000001CA 7950            LDRB             R0, [R2, #5]
  475 000001CC F7FF FFFE       BL               hw1_ascii_to_hex
  476 000001D0         ; first check if valid result
  477 000001D0 F1B0 3FFF       CMP              R0, #0xFFFFFFFF
  478 000001D4         ; if invalid, then increment command address and 
  479 000001D4         ; start search again
  480 000001D4 BF08 1C52       ADDEQ            R2, R2, #1
  481 000001D8 F43F AF76       BEQ              start_search
  482 000001DC         ; if valid, this number is in the 100th place so
  483 000001DC         ; multiply it by 100 and add to sum of what to multiply 
                       in R3
  484 000001DC F04F 0464       MOV              R4, #100
  485 000001E0         ; R3 <-- 5*1000 + (6*100)
  486 000001E0 FB04 3300       MLA              R3, R4, R0, R3
  487 000001E4         
  488 000001E4         ;;;;;;;;;;;;;;;;;;;;;;;;10th place;;;;;;;;;;;;;;;;;;;;;;
                       ;;
  489 000001E4 7990            LDRB             R0, [R2, #6]
  490 000001E6 F7FF FFFE       BL               hw1_ascii_to_hex
  491 000001EA         ; first check if valid result
  492 000001EA F1B0 3FFF       CMP              R0, #0xFFFFFFFF
  493 000001EE         ; if invalid, then increment command address and 
  494 000001EE         ; start search again
  495 000001EE BF08 1C52       ADDEQ            R2, R2, #1
  496 000001F2 F43F AF69       BEQ              start_search
  497 000001F6         ; if valid, this number is in the 10th place so
  498 000001F6         ; multiply it by 10 and add to sum of what to multiply i
                       n R3
  499 000001F6 F04F 040A       MOV              R4, #10
  500 000001FA         ; R3 <-- 5*1000 + (6*100) + (0*10)
  501 000001FA FB04 3300       MLA              R3, R4, R0, R3
  502 000001FE         
  503 000001FE         ;;;;;;;;;;;;;;;;;;;;;;;;1s place;;;;;;;;;;;;;;;;;;;;;;;;
                       
  504 000001FE 79D0            LDRB             R0, [R2, #7]
  505 00000200 F7FF FFFE       BL               hw1_ascii_to_hex
  506 00000204         ; first check if valid result
  507 00000204 F1B0 3FFF       CMP              R0, #0xFFFFFFFF
  508 00000208         ; if invalid, then increment command address and 
  509 00000208         ; start search again
  510 00000208 BF08 1C52       ADDEQ            R2, R2, #1
  511 0000020C F43F AF5C       BEQ              start_search
  512 00000210         ; if valid, this number is in the 1s place so
  513 00000210         ; add to sum of what to multiply and place
  514 00000210         ; in R0 because that is what hw1_wait takes in
  515 00000210         ; R0 <-- 5*1000 + (6*100) + (0*10) + (4*1)
  516 00000210 4418            ADD              R0, R3, R0
  517 00000212         
  518 00000212         ; now R3 has the 4 digit value of how much to halt for



ARM Macro Assembler    Page 11 


  519 00000212         ; though, before calling hw1_wait, multiply R3 by 10,000
                       
  520 00000212 F242 7410       MOV              R4, #10000
  521 00000216 FB00 F004       MUL              R0, R0, R4
  522 0000021A         
  523 0000021A         ; now wait for specified amount of time by calling
  524 0000021A         ; wait function that takes R0 as a parameter
  525 0000021A F7FF FFFE       BL               hw1_wait
  526 0000021E         
  527 0000021E         ; increment the DISPLAY_CMD address in R2
  528 0000021E         ; and check next command
  529 0000021E F102 0201       ADD              R2, R2, #1
  530 00000222 E751            B                start_search
  531 00000224         
  532 00000224         ; To check if 'HALT', see if loaded word in R4 is equiva
                       lent
  533 00000224         ; to 'TLAH', since ARM is little endian. Do this by chec
                       king if the hex
  534 00000224         ; represenation of 'TLAH' is equal to loaded word
  535 00000224         command_HALT
  536 00000224         
  537 00000224 6814            LDR              R4, [R2]
  538 00000226 F244 1348 
              F2C5 434C        MOV32            R3, #0x544C4148
  539 0000022E 429C            CMP              R4, R3
  540 00000230         ; if loaded word and hex representation of 'TLAH' not eq
                       ual
  541 00000230         ; then increment the address of the command array and st
                       art search again
  542 00000230 BF18 1C52       ADDNE            R2, R2, #1
  543 00000234 F47F AF48       BNE              start_search
  544 00000238         infinite_HALT_loop
  545 00000238         ; If command is 'HALT' leave LEDs
  546 00000238         ; in current state and enter an infinite loop.
  547 00000238 E7FE            B                infinite_HALT_loop
  548 0000023A         
  549 0000023A         
  550 0000023A         ; restore changed registers
  551 0000023A BD1F            POP{R0-R4,       PC}
  552 0000023C         ; return
  553 0000023C 4770            BX               LR
  554 0000023E                 ENDP
  555 0000023E         
  556 0000023E 00 00           align
  557 00000240         
  558 00000240                 END
              00000000 
Command Line: --debug --xref --diag_suppress=9931 --cpu=Cortex-M4.fp --apcs=int
erwork --depend=.\obj\hw1.d -o.\obj\hw1.o -I.\RTE\_HW1 -IC:\Keil_v5\ARM\PACK\AR
M\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\TM4C_DFP\1.1.0\Devi
ce\Include\TM4C123 --predefine="__EVAL SETA 1" --predefine="__MICROLIB SETA 1" 
--predefine="__UVISION_VERSION SETA 526" --predefine="_RTE_ SETA 1" --predefine
="TM4C123GH6PM SETA 1" --list=.\lst\hw1.lst hw1.s



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

LED_ARRAY 00000000

Symbol: LED_ARRAY
   Definitions
      At line 15 in file hw1.s
   Uses
      At line 40 in file hw1.s
      At line 142 in file hw1.s
      At line 156 in file hw1.s
      At line 198 in file hw1.s

SRAM 00000000

Symbol: SRAM
   Definitions
      At line 14 in file hw1.s
   Uses
      None
Comment: SRAM unused
2 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

FLASH 00000000

Symbol: FLASH
   Definitions
      At line 21 in file hw1.s
   Uses
      None
Comment: FLASH unused
characters_0_9 0000003A

Symbol: characters_0_9
   Definitions
      At line 96 in file hw1.s
   Uses
      At line 90 in file hw1.s
Comment: characters_0_9 used once
characters_A_F 00000026

Symbol: characters_A_F
   Definitions
      At line 81 in file hw1.s
   Uses
      At line 75 in file hw1.s
Comment: characters_A_F used once
characters_a_f 00000012

Symbol: characters_a_f
   Definitions
      At line 66 in file hw1.s
   Uses
      None
Comment: characters_a_f unused
command_HALT 00000224

Symbol: command_HALT
   Definitions
      At line 535 in file hw1.s
   Uses
      At line 452 in file hw1.s
Comment: command_HALT used once
command_HANG 000001A4

Symbol: command_HANG
   Definitions
      At line 446 in file hw1.s
   Uses
      At line 323 in file hw1.s
Comment: command_HANG used once
command_LEDx 000000E0

Symbol: command_LEDx
   Definitions
      At line 314 in file hw1.s
   Uses
      At line 300 in file hw1.s
Comment: command_LEDx used once
hang_loop_end 000000C0

Symbol: hang_loop_end



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols

   Definitions
      At line 248 in file hw1.s
   Uses
      At line 245 in file hw1.s
Comment: hang_loop_end used once
hang_loop_start 000000BA

Symbol: hang_loop_start
   Definitions
      At line 242 in file hw1.s
   Uses
      At line 247 in file hw1.s
Comment: hang_loop_start used once
hw1_ascii_to_dec 00000042

Symbol: hw1_ascii_to_dec
   Definitions
      At line 117 in file hw1.s
   Uses
      At line 99 in file hw1.s
Comment: hw1_ascii_to_dec used once
hw1_ascii_to_hex 00000010

Symbol: hw1_ascii_to_hex
   Definitions
      At line 59 in file hw1.s
   Uses
      At line 331 in file hw1.s
      At line 355 in file hw1.s
      At line 366 in file hw1.s
      At line 379 in file hw1.s
      At line 391 in file hw1.s
      At line 404 in file hw1.s
      At line 416 in file hw1.s
      At line 460 in file hw1.s
      At line 475 in file hw1.s
      At line 490 in file hw1.s
      At line 505 in file hw1.s

hw1_init 0000004C

Symbol: hw1_init
   Definitions
      At line 137 in file hw1.s
   Uses
      At line 305 in file hw1.s
Comment: hw1_init used once
hw1_ledx 00000078

Symbol: hw1_ledx
   Definitions
      At line 177 in file hw1.s
   Uses
      At line 435 in file hw1.s
Comment: hw1_ledx used once
hw1_search_memory 000000C4

Symbol: hw1_search_memory
   Definitions



ARM Macro Assembler    Page 3 Alphabetic symbol ordering
Relocatable symbols

      At line 268 in file hw1.s
   Uses
      At line 4 in file hw1.s
Comment: hw1_search_memory used once
hw1_update_leds 00000000

Symbol: hw1_update_leds
   Definitions
      At line 36 in file hw1.s
   Uses
      At line 219 in file hw1.s
Comment: hw1_update_leds used once
hw1_wait 000000B4

Symbol: hw1_wait
   Definitions
      At line 236 in file hw1.s
   Uses
      At line 525 in file hw1.s
Comment: hw1_wait used once
infinite_HALT_loop 00000238

Symbol: infinite_HALT_loop
   Definitions
      At line 544 in file hw1.s
   Uses
      At line 547 in file hw1.s
Comment: infinite_HALT_loop used once
return 0000003E

Symbol: return
   Definitions
      At line 100 in file hw1.s
   Uses
      At line 71 in file hw1.s
      At line 79 in file hw1.s
      At line 86 in file hw1.s
      At line 94 in file hw1.s

start_search 000000C8

Symbol: start_search
   Definitions
      At line 294 in file hw1.s
   Uses
      At line 309 in file hw1.s
      At line 337 in file hw1.s
      At line 343 in file hw1.s
      At line 361 in file hw1.s
      At line 372 in file hw1.s
      At line 385 in file hw1.s
      At line 397 in file hw1.s
      At line 410 in file hw1.s
      At line 422 in file hw1.s
      At line 441 in file hw1.s
      At line 466 in file hw1.s
      At line 481 in file hw1.s
      At line 496 in file hw1.s
      At line 511 in file hw1.s



ARM Macro Assembler    Page 4 Alphabetic symbol ordering
Relocatable symbols

      At line 530 in file hw1.s
      At line 543 in file hw1.s

19 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Absolute symbols

BYTE 00000001

Symbol: BYTE
   Definitions
      At line 9 in file hw1.s
   Uses
      None
Comment: BYTE unused
HALF_WORD 00000002

Symbol: HALF_WORD
   Definitions
      At line 8 in file hw1.s
   Uses
      None
Comment: HALF_WORD unused
WORD 00000004

Symbol: WORD
   Definitions
      At line 7 in file hw1.s
   Uses
      At line 15 in file hw1.s
Comment: WORD used once
3 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
External symbols

WS2812B_write 00000000

Symbol: WS2812B_write
   Definitions
      At line 5 in file hw1.s
   Uses
      At line 42 in file hw1.s
      At line 158 in file hw1.s

1 symbol
363 symbols in table
